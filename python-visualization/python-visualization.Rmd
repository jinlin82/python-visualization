---
title: "Python Visualization"
author: "py-vis-team"
date: "2020年3月"
institute: 中南财经政法大学统计与数学学院
csl: ./style/chinese-gb7714-2015-numeric.csl
css: ./style/markdown.css
bibliography: [./Bibfile.bib]
eqnPrefixTemplate: ($$i$$)
link-citations: true
linkReferences: true
chapters: true
tableEqns: false
autoEqnLabels: false
classoption: "aspectratio=1610"
---

```{r setup, echo=F, purl=F}
knitr::opts_knit$set(root.dir = getwd())
knitr::opts_chunk$set(echo = TRUE, results = 'hide')
knitr::opts_chunk$set(warning = FALSE, message=FALSE)
knitr::opts_chunk$set(fig.align="center"
                      ## ,out.width="0.9\\textwidth" # latex
                      ,out.width="90%" # for both latex and html
                      ,fig.width=5, fig.height=3
                      )
```

```{r prepare, echo=F, purl=F}
rm(list=ls())
options(digits=4)
options(scipen=100)
graphics.off()
Sys.setlocale("LC_ALL", "Chinese")
library(reticulate)
```

# 简介

### Facts

1.  Initial release:2003; 13 years ago
2.  Stable release: Stable release: 0.18.1 / 22 September 2016
3.  Website: <http://matplotlib.org>

### What is matplotlib?

1.  matplotlib is a library for making 2D plots of arrays in Python.
2.  Although it has its origins in emulating the MATLAB graphics
    commands, it is independent of MATLAB, and can be used in a
    Pythonic, object oriented way.
3.  Although matplotlib is written primarily in pure Python, it makes
    heavy use of NumPy and other extension code to provide good
    performance even for large arrays.

### three parts

1.  The matplotlib code is conceptually divided into three parts:

1.  the pylab interface is the set of functions provided by matplotlib.
    1.  pylab which allow the user to create plots with code quite
        similar to MATLAB figure generating code.
    2.  Typically pylab is imported to bring NumPy and matplotlib into a
        single global namespace for the most MATLAB like syntax, however
        a more explicit import style, which names both matplotlib and
        NumPy, is the preferred coding style.
2.  The matplotlib frontend or matplotlib API is the set of classes that
    do the heavy lifting, creating and managing figures, text, lines,
    plots and so on.
3.  The backends are device-dependent drawing devices, aka renderers,
    that transform the frontend representation to hardcopy or a display
    device.

# 基本概念

### Two interfaces

1.  matplotlib has two interfaces.
2.  The first is based on MATLAB and uses a state-based interface.
3.  The second option is an an object-oriented(OO) interface.
4.  knowing that there are two approaches is vitally important when
    plotting with matplotlib.

## 图形组成部分

### Figure

1.  The whole figure. The figure keeps track of all the child Axes, a
    smattering of \'special\' artists (titles, figure legends, etc), and
    the canvas.
2.  A figure can have any number of Axes, but to be useful should have
    at least one.
3.  The easiest way to create a new figure is with pyplot:

``` {python}
import matplotlib.pyplot as plt
import numpy as np

fig = plt.figure()  # an empty figure with no axes
fig.suptitle('No axes on this figure')  # Add a title so we know which it is

fig, ax_lst = plt.subplots(2, 2)  # a figure with a 2x2 grid of Axes

```

### Axes

1.  This is what you think of as \'a plot\', it is the region of the
    image with the data space.
2.  A given figure can contain many Axes, but a given Axes object can
    only be in one Figure.
3.  The Axes contains two (or three in the case of 3D) Axis objects (be
    aware of the difference between Axes and Axis) which take care of
    the data limits (the data limits can also be controlled via set via
    the set~xlim~() and set~ylim~() Axes methods).
4.  Each Axes has a title (set via set~title~()), an x-label (set via
    set~xlabel~()), and a y-label set via set~ylabel~()).
5.  The Axes class and its member functions are the primary entry point
    to working with the OO interface.

### Axis

1.  These are the number-line-like objects.
2.  They take care of setting the graph limits and generating the ticks
    (the marks on the axis) and ticklabels (strings labeling the ticks).
3.  The location of the ticks is determined by a Locator object and the
    ticklabel strings are formatted by a Formatter.
4.  The combination of the correct Locator and Formatter gives very fine
    control over the tick locations and labels.

### Artist

1.  Basically everything you can see on the figure is an artist (even
    the Figure, Axes, and Axis objects).
2.  This includes Text objects, Line2D objects, collection objects,
    Patch objects ... (you get the idea).
3.  When the figure is rendered, all of the artists are drawn to the
    canvas.
4.  Most Artists are tied to an Axes; such an Artist cannot be shared by
    multiple Axes, or moved from one to another.

### 其他组成部分

![](images/1580807106.png)

### Types of inputs to plotting functions

1.  All of plotting functions expect np.array or np.ma.masked~array~ as
    input.
2.  Classes that are \'array-like\' such as pandas data objects and
    np.matrix may or may not work as intended.
3.  It is best to convert these to np.array objects prior to plotting.

``` {python}
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

a = pd.DataFrame(np.random.rand(4,5), columns = list('abcde'))
a_asarray = a.values

b = np.matrix([[1,2],[3,4]])
b_asarray = np.asarray(b)
```

### Matplotlib, pyplot and pylab: how are they related?

1.  Matplotlib is the whole package
2.  and matplotlib.pyplot is a module in Matplotlib.
3.  pylab is a convenience module that bulk imports matplotlib.pyplot
    (for plotting) and numpy (for mathematics and working with arrays)
    in a single namespace. pylab is deprecated and its use is strongly
    discouraged because of namespace pollution. Use pyplot instead.

### pyplot

1.  For functions in the pyplot module, there is always a \"current\"
    figure and axes (which is created automatically on request).
2.  For example, in the following example, the first call to plt.plot
    creates the axes,
3.  then subsequent calls to plt.plot add additional lines on the same
    axes,
4.  and plt.xlabel, plt.ylabel, plt.title and plt.legend set the axes
    labels and title and add a legend.

``` {python}
x = np.linspace(0, 2, 100)

plt.plot(x, x, label='linear')
plt.plot(x, x**2, label='quadratic')
plt.plot(x, x**3, label='cubic')

plt.xlabel('x label')
plt.ylabel('y label')
plt.title("Simple Plot")
plt.legend()

plt.show()

```

## 后端

### What is a backend?

1.  matplotlib targets many different use cases and output formats.
2.  To support all of these use cases, matplotlib can target different
    outputs, and each of these capabilities is called a backend;
3.  the \"frontend\" is the user facing code, i.e., the plotting code,
    whereas the \"backend\" does all the hard work behind-the-scenes to
    make the figure.
4.  There are two types of backends:
    1.  user interface backends (for use in pygtk, wxpython, tkinter,
        qt4, or macosx; also referred to as \"interactive backends\")
    2.  and hardcopy backends to make image files (PNG, SVG, PDF, PS;
        also referred to as \"non-interactive backends\").

### Configure your backend

1.  The backend parameter in your matplotlibrc file
2.  If your script depends on a specific backend you can use the use()
    function.
3.  If you use the use() function, this must be done before importing
    matplotlib.pyplot. Calling use() after pyplot has been imported will
    have no effect.
4.  Using use() will require changes in your code if users want to use a
    different backend.

``` {python}
import matplotlib
matplotlib.use('pdf')   ### generate postscript output by default

```

### What is interactive mode?

1.  Use of an interactive backend permits plotting to the screen.
2.  Interactive mode may also be turned on via
    `matplotlib.pyplot.ion()`,
3.  and turned off via `matplotlib.pyplot.ioff()`.
4.  Non-interactive example:

``` {python}
import matplotlib.pyplot as plt
plt.ioff()
plt.plot([1.6, 2.7])

```

1.  Nothing happened--or at least nothing has shown up on the screen, To
    make the plot appear, you need to do this:

``` {python}
plt.show()
```

1.  Now you see the plot, but your terminal command line is
    unresponsive; the `show()` command blocks the input of additional
    commands until you manually kill the plot window.

## Pyplot 简介

### Intro to pyplot

1.  `matplotlib.pyplot` is a collection of command style functions that
    make matplotlib work like MATLAB.
2.  Each pyplot function makes some change to a figure: e.g., creates a
    figure, creates a plotting area in a figure, plots some lines in a
    plotting area, decorates the plot with labels, etc.
3.  In `matplotlib.pyplot` various states are preserved across function
    calls, so that it keeps track of things like the current figure and
    plotting area, and the plotting functions are directed to the
    current axes.
4.  \"axes\" here and in most places in the documentation refers to the
    axes part of a figure and not the strict mathematical term for more
    than one axis.

### Formatting the style of your plot

1.  For every x, y pair of arguments, there is an optional third
    argument which is the format string that indicates the color and
    line type of the plot.
2.  The letters and symbols of the format string are from MATLAB, and
    you concatenate a color string with a line style string.
3.  The default format string is `'b-'` , which is a solid blue line.
    For example, to plot the above with red circles, use `'ro'` .
4.  The `axis()` command in the example above takes a list of
    `[xmin, xmax, ymin, ymax]` and specifies the viewport of the axes.

``` {python}
import matplotlib.pyplot as plt
plt.plot([1, 2, 3, 4], [1, 4, 9, 16], 'ro')
plt.axis([0, 6, 0, 20])
plt.show()

```

### use numpy arrays

1.  matplotlib uses numpy arrays.
2.  In fact, all sequences are converted to numpy arrays internally.
3.  The example below illustrates a plotting several lines with
    different format styles in one command using arrays.

``` {python}
import numpy as np

# evenly sampled time at 200ms intervals
t = np.arange(0., 5., 0.2)

# red dashes, blue squares and green triangles
plt.plot(t, t, 'r--', t, t**2, 'bs', t, t**3, 'g^')
plt.show()
```

### Plotting with keyword strings

1.  There are some instances where you have data in a format that lets
    you access particular variables with strings.
2.  For example, `pandas.DataFrame`.
3.  Matplotlib allows you provide such an object with the `data` keyword
    argument.
4.  If provided, then you may generate plots with the strings
    corresponding to these variables.

``` {python}
data = {'a': np.arange(50),
        'c': np.random.randint(0, 50, 50),
        'd': np.random.randn(50)}
data['b'] = data['a'] + 10 * np.random.randn(50)
data['d'] = np.abs(data['d']) * 100

plt.scatter('a', 'b', c='c', s='d', data=data)
plt.xlabel('entry a')
plt.ylabel('entry b')
plt.show()
```

### Plotting with categorical variables

1.  Matplotlib allows you to pass categorical variables directly to many
    plotting functions.

``` {python}
names = ['group_a', 'group_b', 'group_c']
values = [1, 10, 100]

plt.figure(figsize=(9, 3))

plt.subplot(131)
plt.bar(names, values)
plt.subplot(132)
plt.scatter(names, values)
plt.subplot(133)
plt.plot(names, values)
plt.suptitle('Categorical Plotting')
plt.show()
```

## 线条属性

### Controlling line properties

1.  Lines have many attributes that you can set: linewidth, dash style,
    antialiased, etc; see matplotlib.lines.Line2D.
2.  There are several ways to set line properties:
    1.  Use keyword args: `plt.plot(x, y, linewidth=2.0)`
    2.  Use the setter methods of a Line2D instance. plot returns a list
        of Line2D objects; e.g., line1, line2 = plot(x1, y1, x2, y2). In
        the code below we will suppose that we have only one line so
        that the list returned is of length 1. We use tuple unpacking
        with line, to get the first element of that list:

``` {python, eval=F}
line, = plt.plot(x, y, '-')
line.set_antialiased(False) # turn off antialiasing
```

### Controlling line properties

1.  Use the `setp()` command. The example below uses a MATLAB-style
    command to set multiple properties on a list of lines. setp works
    transparently with a list of objects or a single object. You can
    either use python keyword arguments or MATLAB-style string/value
    pairs.

``` {python, eval=F}
lines = plt.plot(x1, y1, x2, y2)
# use keyword args
plt.setp(lines, color='r', linewidth=2.0)
# or MATLAB style string value pairs
plt.setp(lines, 'color', 'r', 'linewidth', 2.0)
```

1.  To get a list of settable line properties, call the `setp()`
    function with a line or lines as argument.

``` {python}
lines = plt.plot([1, 2, 3])
plt.setp(lines)
```

## 多个图形和坐标系

### Working with multiple figures and axes

1.  pyplot has the concept of the current figure and the current axes.
2.  All plotting commands apply to the current axes.
3.  The function `gca()` returns the current axes (a
    matplotlib.axes.Axes instance),
4.  and `gcf()` returns the current figure (matplotlib.figure.Figure
    instance).
5.  Normally, you don\'t have to worry about this, because it is all
    taken care of behind the scenes.

``` {python}
def f(t):
    return np.exp(-t) * np.cos(2*np.pi*t)

t1 = np.arange(0.0, 5.0, 0.1)
t2 = np.arange(0.0, 5.0, 0.02)
plt.figure()
plt.subplot(211)
plt.plot(t1, f(t1), 'bo', t2, f(t2), 'k')
plt.subplot(212)
plt.plot(t2, np.cos(2*np.pi*t2), 'r--')
plt.show()
```

### Working with multiple figures and axes

1.  The figure() command here is optional because figure(1) will be
    created by default, just as a subplot(111) will be created by
    default if you don\'t manually specify any axes.
2.  The subplot() command specifies numrows, numcols, plot~number~ where
    plot~number~ ranges from 1 to numrows\*numcols.
3.  The commas in the subplot command are optional if
    numrows\*numcols\<10. So subplot(211) is identical to subplot(2, 1,
    1).
4.  create multiple figures by using multiple figure() calls with an
    increasing figure number.
5.  clear the current figure with clf() and the current axes with cla().
6.  the memory required for a figure is not completely released until
    the figure is explicitly closed with close().

### 例子

``` {python}
import matplotlib.pyplot as plt
plt.figure(1)                # the first figure
plt.subplot(211)             # the first subplot in the first figure
plt.plot([1, 2, 3])
plt.subplot(212)             # the second subplot in the first figure
plt.plot([4, 5, 6])


plt.figure(2)                # a second figure
plt.plot([4, 5, 6])          # creates a subplot(111) by default

plt.figure(1)                # figure 1 current; subplot(212) still current
plt.subplot(211)             # make subplot(211) in figure1 current
plt.title('Easy as 1, 2, 3') # subplot 211 title

```

Working with text
-----------------

### Working with text

1.  The text() command can be used to add text in an arbitrary location,
2.  and the xlabel(), ylabel() and title() are used to add text in the
    indicated locations.
3.  All of the text() commands return an matplotlib.text.Text instance.
4.  Just as with with lines above, you can customize the properties by
    passing keyword arguments into the text functions or using setp():

``` {python}
t = plt.xlabel('my data', fontsize=14, color='red')
```

### 例子

``` {python}
mu, sigma = 100, 15
x = mu + sigma * np.random.randn(10000)

# the histogram of the data
n, bins, patches = plt.hist(x, 50, density=1, facecolor='g', alpha=0.75)


plt.xlabel('Smarts')
plt.ylabel('Probability')
plt.title('Histogram of IQ')
plt.text(60, .025, r'$\mu=100,\ \sigma=15$')
plt.axis([40, 160, 0, 0.03])
plt.grid(True)
plt.show()

```

### Using mathematical expressions in text

1.  matplotlib accepts TeX equation expressions in any text expression.

``` {python}
plt.title(r'$\sigma_i=15$')
```

1.  The r preceding the title string is important -- it signifies
    that the string is a raw string and not to treat backslashes as
    python escapes.
2.  matplotlib has a built-in TeX expression parser and layout engine,
    and ships its own math fonts. Thus you can use mathematical text
    across platforms without requiring a TeX installation.
3.  For those who have LaTeX and dvipng installed, you can also use
    LaTeX to format your text and incorporate the output directly into
    your display figures or saved postscript

### Annotating text

1.  A common use for text is to annotate some feature of the plot, and
    the annotate() method provides helper functionality to make
    annotations easy.
2.  In an annotation, there are two points to consider:
    1.  the location being annotated represented by the argument xy
    2.  and the location of the text xytext.
    3.  Both of these arguments are (x,y) tuples.

### 例子

``` {python}
ax = plt.subplot(111)

t = np.arange(0.0, 5.0, 0.01)
s = np.cos(2*np.pi*t)
line, = plt.plot(t, s, lw=2)

plt.annotate('local max', xy=(2, 1), xytext=(3, 1.5),
             arrowprops=dict(facecolor='black', shrink=0.05),
             )

plt.ylim(-2, 2)
plt.show()
```

# 面向对象API

### the Object-Oriented API vs Pyplot

1.  Matplotlib has two interfaces. The first is an object-oriented (OO)
    interface. In this case, we utilize an instance of axes.Axes in
    order to render visualizations on an instance of figure.Figure.
2.  The second is based on MATLAB and uses a state-based interface. This
    is encapsulated in the pyplot module.
3.  Most of the terms are straightforward but the main thing to remember
    is that:
    1.  The Figure is the final image that may contain 1 or more Axes.
    2.  The Axes represent an individual plot (don\'t confuse this with
        the word \"axis\", which refers to the x/y axis of a plot).
    3.  We call methods that do the plotting directly from the Axes,
        which gives us much more flexibility and power in customizing
        our plot.
4.  In general, try to use the object-oriented interface over the pyplot
    interface.

### data

``` {python}
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter

data = {'Barton LLC': 109438.50,
        'Frami, Hills and Schmidt': 103569.59,
        'Fritsch, Russel and Anderson': 112214.71,
        'Jerde-Hilpert': 112591.43,
        'Keeling LLC': 100934.30,
        'Koepp Ltd': 103660.54,
        'Kulas Inc': 137351.96,
        'Trantow-Barrows': 123381.38,
        'White-Trantow': 135841.99,
        'Will LLC': 104437.60}

group_data = list(data.values())
group_names = list(data.keys())
group_mean = np.mean(group_data)


```

### Figure and axes

1.  To do this with the object-oriented approach, we\'ll first generate
    an instance of figure.Figure and axes.Axes.
2.  The Figure is like a canvas, and the Axes is a part of that canvas
    on which we will make a particular visualization.
3.  Figures can have multiple axes on them.

``` {python}
fig, ax = plt.subplots()
```

1.  Now that we have an Axes instance, we can plot on top of it.

``` {python}
ax.barh(group_names, group_data)
```

### Controlling the style

1.  There are many styles available in Matplotlib in order to let you
    tailor your visualization to your needs. To see a list of styles, we
    can use:

``` {python}
print(plt.style.available)
```

1.  You can activate a style with the following:

``` {python}
plt.style.use('ggplot')
```

### Customizing the plot

1.  rotate the labels on the x-axis so that they show up more clearly.
2.  We can gain access to these labels with the
    axes.Axes.get~xticklabels~() method:

``` {python}
fig, ax = plt.subplots()
ax.barh(group_names, group_data)
labels = ax.get_xticklabels()
```

1.  If we\'d like to set the property of many items at once, it\'s
    useful to use the pyplot.setp() function.
2.  This will take a list (or many lists) of Matplotlib objects, and
    attempt to set some style element of each one.

``` {python}
fig, ax = plt.subplots()
ax.barh(group_names, group_data)
labels = ax.get_xticklabels()
plt.setp(labels, rotation=45, horizontalalignment='right')
```

### Customizing the plot

1.  tell Matplotlib to automatically make room for elements in the
    figures that we create.
2.  To do this we\'ll set the autolayout value of our rcParams.

``` {python}
plt.rcParams.update({'figure.autolayout': True})

fig, ax = plt.subplots()
ax.barh(group_names, group_data)
labels = ax.get_xticklabels()
plt.setp(labels, rotation=45, horizontalalignment='right')
```

1.  add labels to the plot. To do this with the OO interface, we can use
    the axes.Axes.set() method to set properties of this Axes object.
2.  adjust the size of this plot using the pyplot.subplots() function.
    We can do this with the figsize kwarg.
3.  For labels, we can specify custom formatting guidelines in the form
    of functions by using the ticker.FuncFormatter class.

### Customizing the plot

``` {python}
def currency(x, pos):
    """The two args are the value and tick position"""
    if x >= 1e6:
        s = '${:1.1f}M'.format(x*1e-6)
    else:
        s = '${:1.0f}K'.format(x*1e-3)
    return s

formatter = FuncFormatter(currency)

fig, ax = plt.subplots(figsize=(6, 8))
ax.barh(group_names, group_data)
labels = ax.get_xticklabels()
plt.setp(labels, rotation=45, horizontalalignment='right')

ax.set(xlim=[-10000, 140000], xlabel='Total Revenue', ylabel='Company',
       title='Company Revenue')
ax.xaxis.set_major_formatter(formatter)
```

### Combining multiple visualizations

1.  It is possible to draw multiple plot elements on the same instance
    of axes.Axes.
2.  To do this we simply need to call another one of the plot methods on
    that axes object.

### Combining multiple visualizations

``` {python, eval=F}
fig, ax = plt.subplots(figsize=(8, 8))
ax.barh(group_names, group_data)
labels = ax.get_xticklabels()
plt.setp(labels, rotation=45, horizontalalignment='right')
# Add a vertical line, here we set the style in the function call
ax.axvline(group_mean, ls='--', color='r')
# Annotate new companies
for group in [3, 5, 8]:
    ax.text(145000, group, "New Company", fontsize=10,
            verticalalignment="center")
# Now we'll move our title up since it's getting a little cramped
ax.title.set(y=1.05)
ax.set(xlim=[-10000, 140000], xlabel='Total Revenue', ylabel='Company',
       title='Company Revenue')
ax.xaxis.set_major_formatter(formatter)
ax.set_xticks([0, 25e3, 50e3, 75e3, 100e3, 125e3])
fig.subplots_adjust(right=.1)
plt.show()
```

### Saving plots

1.  There are many file formats we can save to in Matplotlib. To see a
    list of available options, use:

``` {python}
print(fig.canvas.get_supported_filetypes())
```

1.  We can then use the figure.Figure.savefig() in order to save the
    figure to disk.
2.  Note that there are several useful flags:
    1.  transparent=True makes the background of the saved figure
        transparent if the format supports it.
    2.  dpi=80 controls the resolution (dots per square inch) of the
        output.
    3.  bbox~inches~=\"tight\" fits the bounds of the figure to our
        plot.

``` {python}
fig.savefig('sales.png', transparent=False, dpi=80, bbox_inches="tight")
```

# 通过样式表单和 rcParams 参数控制图形

## 样式表单

### Using style sheets

1.  The style package adds support for easy-to-switch plotting
    \"styles\" with the same parameters as a `matplotlib rc` file (which
    is read at startup to configure matplotlib).
2.  There are a number of pre-defined styles provided by Matplotlib. For
    example, there\'s a pre-defined style called \"ggplot\", which
    emulates the aesthetics of ggplot (a popular plotting package for
    R).

``` {python}
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
plt.style.use('ggplot')
data = np.random.randn(50)
```

1.  To list all available styles, use: `print(plt.style.available)`

### Defining your own style

1.  You can create custom styles and use them by calling style.use with
    the path or URL to the style sheet.
2.  Additionally, if you add your \<style-name\>.mplstyle file to
    mpl~configdir~/stylelib, you can reuse your custom style sheet with
    a call to style.use(\<style-name\>).

### Composing styles

1.  Style sheets are designed to be composed together.
2.  So you can have a style sheet that customizes colors and a separate
    style sheet that alters element sizes for presentations.
3.  These styles can easily be combined by passing a list of styles:
4.  Note that styles further to the right will overwrite values that are
    already defined by styles on the left.

``` {python}
# plt.style.use(['dark_background', 'presentation'])
```

### Temporary styling

1.  use a style for a specific block of code but don\'t want to change
    the global styling, the style package provides a context manager for
    limiting your changes to a specific scope. To isolate your styling
    changes, you can write something like the following:

``` {python}
with plt.style.context('dark_background'):
    plt.plot(np.sin(np.linspace(0, 2 * np.pi)), 'r-o')

plt.show()
```

## rcParams 参数

### Dynamic rc settings

1.  You can also dynamically change the default rc settings in a python
    script or interactively from the python shell.
2.  All of the rc settings are stored in a dictionary-like variable
    called matplotlib.rcParams, which is global to the matplotlib
    package.
3.  rcParams can be modified directly, for example:

``` {python}
mpl.rcParams['lines.linewidth'] = 2
mpl.rcParams['lines.color'] = 'r'
plt.plot(data)

```

### Dynamic rc settings

1.  Matplotlib also provides a couple of convenience functions for
    modifying rc settings. The matplotlib.rc() command can be used to
    modify multiple settings in a single group at once, using keyword
    arguments.
2.  The matplotlib.rcdefaults() command will restore the standard
    matplotlib default settings.
3.  There is some degree of validation when setting the values of
    rcParams, see matplotlib.rcsetup for details.

``` {python}
mpl.rc('lines', linewidth=4, color='g')
plt.plot(data)
```

### The matplotlibrc file

1.  matplotlib uses matplotlibrc configuration files to customize all
    kinds of properties, which we call rc settings or rc parameters.
2.  You can control the defaults of almost every property in matplotlib:
    figure size and dpi, line width, color and style, axes, axis and
    grid properties, text and font properties and so on.
3.  Once a matplotlibrc file has been found, it will not search any of
    the other paths.
4.  To display where the currently active matplotlibrc file was loaded
    from, one can do the following:

``` {python}
import matplotlib
matplotlib.matplotlib_fname()
```

# Artist 简介

## 基本概念


### three layers to the matplotlib API

1.  the matplotlib.backend~bases~.FigureCanvas is the area onto which
    the figure is drawn
2.  the matplotlib.backend~bases~.Renderer is the object which knows how
    to draw on the FigureCanvas
3.  and the matplotlib.artist.Artist is the object that knows how to use
    a renderer to paint onto the canvas.
4.  Typically, all visible elements in a figure are subclasses of
    Artist.

### three layers to the matplotlib API

1.  The FigureCanvas and Renderer handle all the details of talking to
    user interface toolkits like wxPython or drawing languages like
    PostScript®,
2.  and the Artist handles all the high level constructs like
    representing and laying out the figure, text, and lines.
3.  The typical user will spend 95% of their time working with the
    Artists.

### two types of Artists: primitives and containers

1.  The primitives represent the standard graphical objects we want to
    paint onto our canvas: `Line2D, Rectangle, Text, AxesImage`, etc.,
2.  and the containers are places to put them (`Axis, Axes and Figure`).
3.  The standard use is to create a Figure instance, use the Figure to
    create one or more Axes or Subplot instances,
4.  and use the Axes instance helper methods to create the primitives.

### how to create Figure instance

1.  we can create a Figure instance using matplotlib.pyplot.figure(),
    which is a convenience method for instantiating Figure instances and
    connecting them with your user interface or drawing toolkit
    FigureCanvas. However, this is not necessary.
2.  you can work directly with PostScript, PDF Gtk+, or wxPython
    FigureCanvas instances, instantiate your Figures directly and
    connect them yourselves.

``` {python}
import matplotlib.pyplot as plt
fig = plt.figure()
ax = fig.add_subplot(2, 1, 1) # two rows, one column, first plot
```

### Axes

1.  The Axes is probably the most important class in the matplotlib API,
    and the one you will be working with most of the time.
2.  This is because the Axes is the plotting area into which most of the
    objects go,
3.  and the Axes has many special helper methods (plot(), text(),
    hist(), imshow()) to create the most common graphics primitives
    (Line2D, Text, Rectangle, Image, respectively).
4.  These helper methods will take your data (e.g., numpy arrays and
    strings) and create primitive Artist instances as needed (e.g.,
    Line2D), add them to the relevant containers, and draw them when
    requested.
5.  Most of you are probably familiar with the Subplot, which is just a
    special case of an Axes that lives on a regular rows by columns grid
    of Subplot instances.
6.  If you want to create an Axes at an arbitrary location, simply use
    the add~axes~() method which takes a list of \[left, bottom, width,
    height\] values in 0-1 relative figure coordinates:

### 例子

``` {python}
fig2 = plt.figure()
ax2 = fig2.add_axes([0.15, 0.1, 0.7, 0.3])

import numpy as np
t = np.arange(0.0, 1.0, 0.01)
s = np.sin(2*np.pi*t)
line, = ax.plot(t, s, color='blue', lw=2)

type(ax.lines)
len(ax.lines)
type(line)
```

1.  ax is the Axes instance created by the fig.add~subplot~ call above
    (remember Subplot is just a subclass of Axes)
2.  and when you call ax.plot, it creates a Line2D instance and adds it
    to the Axes.lines list.
3.  remove lines by calling the list methods

## 控制对象

### 简介

1.  Every element in the figure is represented by a matplotlib Artist,
2.  and each has an extensive list of properties to configure its
    appearance.
3.  The figure itself contains a Rectangle exactly the size of the
    figure, which you can use to set the background color and
    transparency of the figures.
4.  each Axes bounding box (the standard white box with black edges in
    the typical matplotlib plot, has a Rectangle instance that
    determines the color, transparency, and other properties of the
    Axes.
5.  These instances are stored as member variables `Figure.patch` and
    `Axes.patch`.

### get Properties list

1.  Every matplotlib Artist has many properties.
2.  inspect the Artist properties is to use the
    `matplotlib.artist.getp()` Function (simply `getp()` in pyplot),
    which lists the properties and their values. This works for classes
    derived from Artist as well, e.g., Figure and Rectangle.

``` {python}
plt.getp(fig)
plt.getp(ax)
```

### get and set properties

1.  Each of the properties is accessed with an old-fashioned setter or
    getter.
2.  If you want to set a number of properties at once, you can also use
    the set method with keyword arguments.

``` {python, eval=F}
a = line.get_alpha()
line.set_alpha(0.5*a)

line.set(alpha=0.5, zorder=2)
```

## 对象容器

### Figure container

1.  The top level container Artist is the matplotlib.figure.Figure, and
    it contains everything in the figure.
2.  The background of the figure is a Rectangle which is stored in
    Figure.patch.
3.  As you add subplots (add~subplot~()) and axes (add~axes~()) to the
    figure these will be appended to the Figure.axes.
4.  Because the figure maintains the concept of the \"current axes\"
    (see Figure.gca and Figure.sca) to support the pyplot state machine,
    you should not insert or remove axes directly from the axes list,
    but rather use the add~subplot~() and add~axes~() methods to insert,
    and the delaxes() method to delete.
5.  iterate over the list of axes or index into it to get access to Axes
    instances you want to customize.

### 例子

``` {python}
fig = plt.figure()

ax1 = fig.add_subplot(211)
ax2 = fig.add_axes([0.1, 0.1, 0.7, 0.3])
print(fig.axes)

for ax in fig.axes:
    ax.grid(True)

```

### Axes container

1.  The matplotlib.axes.Axes is the center of the matplotlib universe.
2.  it contains the vast majority of all the Artists used in a figure
    with many helper methods to create and add these Artists to itself,
    as well as helper methods to access and customize the Artists it
    contains.
3.  Like the Figure, it contains a Patch patch which is a Rectangle for
    Cartesian coordinates and a Circle for polar coordinates;
4.  this patch determines the shape, background and border of the
    plotting region.

### Axis containers

1.  The matplotlib.axis.Axis instances handle the drawing of the tick
    lines, the grid lines, the tick labels and the axis label.
2.  You can configure the left and right ticks separately for the
    y-axis, and the upper and lower ticks separately for the x-axis.
3.  The Axis also stores the data and view intervals used in
    auto-scaling, panning and zooming, as well as the Locator and
    Formatter instances which control where the ticks are placed and how
    they are represented as strings.
4.  Each Axis object contains a label attribute (this is what pyplot
    modifies in calls to xlabel() and ylabel()) as well as a list of
    major and minor ticks.
5.  The ticks are XTick and YTick instances, which contain the actual
    line and text primitives that render the ticks and ticklabels.
6.  access the lists of major and minor ticks through their accessor
    methods get~majorticks~() and get~minorticks~().

### 例子

``` {python}
fig, ax = plt.subplots()
axis = ax.xaxis
axis.get_ticklocs()

axis.get_ticklabels()
axis.get_ticklines()
axis.get_ticklines(minor=True)
```

1.  note there are twice as many ticklines as labels because by default
    there are tick lines at the top and bottom but only tick labels
    below the xaxis.

### Tick containers

1.  The matplotlib.axis.Tick is the final container object in our
    descent from the Figure to the Axes to the Axis to the Tick.
2.  The Tick contains the tick and grid line instances, as well as the
    label instances for the upper and lower ticks.
3.  Each of these is accessible directly as an attribute of the Tick.

### 例子

``` {python, eval=F}
np.random.seed(19680801)

fig, ax = plt.subplots()
ax.plot(100*np.random.rand(20))

formatter = ticker.FormatStrFormatter('$%1.2f')
ax.yaxis.set_major_formatter(formatter)

for tick in ax.yaxis.get_major_ticks():
    tick.label1.set_visible(False)
    tick.label2.set_visible(True)
    tick.label2.set_color('green')

plt.show()
```

# 图例

### 三种用法

1.  `legend()`
2.  `legend(labels)`
3.  `legend(handles, labels)`

### Automatic detection of elements to be shown in the legend(自动检测元素添加到
图例中)

1.  The elements to be added to the legend are automatically determined,
    when you do not pass in any extra arguments.（当没有选择额外参数时，将自动确
    定要添加到图例的元素）
2.  In this case, the labels are taken from the artist.（在这种情况下，标签来自
于美学映射）
3.  You can specify them either at artist creation or by calling the
    set~label~() method on the artist.（可以在创建美学映射时指定，也可以通过调用
   set_label()函数的方法）
4.  Specific lines can be excluded from the automatic legend element
    selection by defining a label starting with an underscore.（通过定义以下划线
   开头的标签可以从自动图例元素中排除特定的线）
5.  This is default for all artists, so calling Axes.legend without any
    arguments and without setting the labels manually will result in no
    legend being drawn.（这是默认设置，所以当没有手动设置标签直接调用
    Axes.legend()函数将不会显示任何图例）

### 例子

``` {python}
line, = plt.plot([1, 2, 3], label='Inline label')
plt.legend()

line, = plt.plot([1, 2, 3])
line.set_label('Label via method')
plt.legend()

```

### Labeling existing plot elements（标记现有的绘图元素）

1.  To make a legend for lines which already exist on the axes (via plot
    for instance), simply call this function with an iterable of
    strings, one for each legend item.（为已有的线制作图例（通过绘图，例如）简单
    调用plt.legend()函数，为每一条线指定一个标签字符串）
2.  Note: This way of using is discouraged, because the relation between
    plot elements and labels is only implicit by their order and can
    easily be mixed up.（注意：不鼓励使用这种方法，因为通过它们的顺序确定绘图元
    素和标签之间的关系是隐晦的，很容易搞混乱）

``` {python}
plt.plot([1, 2, 3])
plt.legend(['A simple line'])

```

### Explicitly defining the elements in the legend（明确定义图例中的元素）

1.  For full control of which artists have a legend entry, it is
    possible to pass an iterable of legend artists followed by an
    iterable of legend labels respectively.（为了完全控制每一条线有一个图例，可
    以通过指定一个可迭代的图例标签给要需要添加到图例上的线）

`legend((line1, line2, line3), ('label1', 'label2', 'label3'))`

1.  Parameters:
    1.  loc : The location of the legend. \'best\'
    2.  bbox~toanchor~: Box that is used to position the legend in
        conjunction with loc.
    3.  fontsize

### 例子

1.  Examples using matplotlib.pyplot.legend，更多例子见：
    <https://matplotlib.org/api/_as_gen/matplotlib.pyplot.legend.html#matplotlib.pyplot.legend>

``` {python}
import numpy as np
import matplotlib.pyplot as plt
# Make some fake data.
a = b = np.arange(0, 3, .02)
c = np.exp(a)
d = c[::-1]
# Create plots with pre-defined labels.
fig, ax = plt.subplots()
ax.plot(a, c, 'k--', label='Model length')
ax.plot(a, d, 'k:', label='Data length')
ax.plot(a, c + d, 'k', label='Total message length')
legend = ax.legend(loc='upper center', shadow=True, fontsize='x-large')
# Put a nicer background color on the legend.
legend.get_frame().set_facecolor('C0')

plt.show()
```

# 紧缩输出和限定输出

### Tight Layout

1.  tight~layout~ automatically adjusts subplot params so that the
    subplot(s) fits in to the figure area.(紧缩输出自动调整子图参数，以便子图适
    合于图形区域)
2.  tight~layout~() only considers ticklabels, axis labels, and titles.
    Thus, other artists may be clipped and also may overlap.（紧缩输出只考虑刻度
    标签、轴标签和标题。因此，其他的美学映射可能被剪裁也可能重叠。）
3.  An alternative to tight~layout~ is constrained~layout~.（紧缩输出的另一种选择
是限定输出）
4.  To prevent this, the location of axes needs to be adjusted. For
    subplots, this can be done by adjusting the subplot params (Move the
    edge of an axes to make room for tick labels).（为了防止这种情况发生，轴的位
    置需要被调整，对于子图，可以调整子图参数完成（移动轴的边缘为刻度标签腾出空间））
5.  `tight_layout()` that does this automatically for you.（tight_layout()函数自
动执行）
6.  Note that `matplotlib.pyplot.tight_layout()` will only adjust the
    subplot params when it is called.（注意到只用被调用时才会调整子图的参数）
7.  In order to perform this adjustment each time the figure is redrawn,
    you can call `fig.set_tight_layout(True)`, or, equivalently, set the
    figure.autolayout rcParam to True.（为了每次重新绘制图形时执行该操作，可以调
    用函数fig.set_tight_layout(True)，或者用plt.rcParams['figure.autolayout']=True）

### 例子

``` {python}
import matplotlib.pyplot as plt
import numpy as np
plt.rcParams['savefig.facecolor'] = "0.8"

def example_plot(ax, fontsize=12):
    ax.plot([1, 2])

    ax.locator_params(nbins=3)
    ax.set_xlabel('x-label', fontsize=fontsize)
    ax.set_ylabel('y-label', fontsize=fontsize)
    ax.set_title('Title', fontsize=fontsize)

plt.close('all')
fig, ax = plt.subplots()
example_plot(ax, fontsize=24)

fig, ax = plt.subplots()
example_plot(ax, fontsize=24)
plt.tight_layout()
```

### multiple subplots(多个子图)

1.  When you have multiple subplots, often you see labels of different
    axes overlapping each other.（当有多个子图时，通常会出现不同坐标轴的标签互相重叠
   的情况）
2.  tight~layout~() will also adjust spacing between subplots to
    minimize the overlaps.（tight_layout()函数也可以调整不同子图之间的空间尽量减
    少出现重叠的情况）
3.  tight~layout~() will work even if the sizes of subplots are
    different as far as their grid specification is compatible.（tight_layout()
    函数对不同大小的子图也同样起作用，只要网格条件是兼容的）

### 例子

``` {python}
plt.close('all')
fig = plt.figure()

ax1 = plt.subplot(221)
ax2 = plt.subplot(223)
ax3 = plt.subplot(122)

example_plot(ax1)
example_plot(ax2)
example_plot(ax3)

plt.tight_layout()
```

### Constrained Layout

1.  constrained~layout~ automatically adjusts subplots and decorations
    like legends and colorbars so that they fit in the figure window
    while still preserving, as best they can, the logical layout
    requested by the user.（constrained_layout()函数自动调整子图、图例和颜色条，
   以便适合图形窗口，但是仍尽可能的保留逻辑布局）
2.  constrained~layout~ is similar to tight~layout~, but uses a
    constraint solver to determine the size of axes that allows them to
    fit.（constrained_layout()和tight_layout()相似，不过用了一个约束解算器用于确
    定轴的大小）
3.  constrained~layout~ needs to be activated before any axes are added
    to a figure. Two ways of doing so are（constrained_layout()需要先被激活，在
    添加任何轴到图形前。有两种方法：）
    1.  using the respective argument to subplots() or figure(), e.g.:
        `plt.subplots(constrained_layout=True)`（使用各自的参数到子图或者图形，例如plt.subplots(constrained_layout=True)）
    2.  activate it via rcParams, like:
        `plt.rcParams['figure.constrained_layout.use'] = True`（通过rcParams激
        活，设置plt.rcParams['figure.constrained_layout.use'] = True）

### 例子

``` {python}
fig, ax = plt.subplots(constrained_layout=False)
example_plot(ax, fontsize=24)

fig, ax = plt.subplots(constrained_layout=True)
example_plot(ax, fontsize=24)

fig, axs = plt.subplots(2, 2, constrained_layout=False)
for ax in axs.flat:
    example_plot(ax)

fig, axs = plt.subplots(2, 2, constrained_layout=True)
for ax in axs.flat:
    example_plot(ax)
```

# 图形中的文本

### 简介

1.  Matplotlib具有广泛的文本支持，包括对数学表达式的支持、对光栅和向量输出的字体支持、带有任意旋转的换行分隔文本以及字符编码支持
    
2.  Matplotlib包含自己的Matplotlib.font_manager模块,可以实现跨平台、W3C兼容的字体查找算法。
   
3.  用户对文本属性（字体大小,字体的粗细，文字的位置和颜色等）有很大的控制权，可以通过rc文件进行合理的修改。值得注意的是，对于那些对数学或科学图形感兴趣的人，Matplotlib实现了大量TeX数学符号和命令，支持图形中的任何数学表达式。

### Basic text commands

  pyplot API   OO API        description
  ------------ ------------- ----------------------------------------------------------------------------------
  text         text          在轴的任意位置添加文本。
  annotate     annotate      在坐标轴的任意位置添加带有可选箭头的注释。
  xlabel       set~xlabel~   在坐标轴的x轴上添加一个标签。
  ylabel       set~ylabel~   在坐标轴的y轴上添加一个标签。
  title        set~title~    给这些轴添加一个标题。
  figtext      text          在图形的任意位置添加文本。
  suptitle     suptitle      给图添加一个标题。

-   所有这些函数都创建并返回一个文本实例，该实例可以配置为各种字体和其他属性。

### 例子

``` {python}
import matplotlib
import matplotlib.pyplot as plt

fig = plt.figure()
ax = fig.add_subplot(111)
fig.subplots_adjust(top=0.85) #（调整图形高度）
# Set titles for the figure and the subplot respectively
fig.suptitle('bold figure suptitle', fontsize=14, fontweight='bold') # 添加图标题
ax.set_title('axes title')  #添加轴标题
ax.set_xlabel('xlabel')  # 添加轴标签
ax.set_ylabel('ylabel')  # 添加轴标签
# Set both x- and y-axis limits to [0, 10] instead of default [0, 1]
ax.axis([0, 10, 0, 10]) # 修改轴坐标范围
ax.text(3, 8, 'boxed italics text in data coords', style='italic',
        bbox={'facecolor': 'red', 'alpha': 0.5, 'pad': 10}) # 在指定位置添加文本，alpha对应透明度，pad对应图形宽度
ax.text(3, 2, 'unicode: Institut für Festkörperphysik')
ax.text(0.95, 0.01, 'colored text in axes coords',
        verticalalignment='bottom', horizontalalignment='right',
        transform=ax.transAxes,
        color='green', fontsize=15)

ax.plot([2], [1], 'o')
ax.annotate('annotate', xy=(2, 1), xytext=(3, 4),
            arrowprops=dict(facecolor='black', shrink=0.05)) # shrink箭头长短
plt.show()

plt.getp(ax.texts)
```

### Text properties and layout

1.  matplotlib.text文本实例具有各种属性
2.  这些属性可以通过文本命令的关键字参数(例如，title()、xlabel()和text())来配置
3.  通过“pl .getp(ax.text)”获取属性列表

### Default Font

1.  基本默认字体由一组rcParams控制。

  rcParam            usage
  ------------------ ---------------------------------------------------------------------------------------------------------------------------------
  \'font.family\'    字体名称列表，例如{\'cursive\', \'fantasy\', \'monospace\', \'sans\', \'sans serif\', \'sans-serif\', \'serif\'}.
  \'font.style\'     默认样式, 例如 \'normal\', \'italic\'.
  \'font.variant\'   默认变体, ex \'normal\', \'small-caps\' (untested)
  \'font.stretch\'   默认延伸, ex \'normal\', \'condensed\' (incomplete)
  \'font.weight\'    默认空间大小。字符串或整数
  \'font.size\'      默认字体大小(以点为单位)。相对字体大小 (\'large\', \'x-small\') 是根据这个大小计算的。

### Text with non-latin glyphs

1.  Matplotlib仍然没有覆盖用户可能需要的所有符号。
2.  例如，DejaVu没有覆盖中文、韩语或日语。
3.  将默认字体设置修改为支持所需字体，将字体名称前置到\'font.family\ 或列表中。
    1.  `matplotlib.rcParams['font.sans-serif'] = ['SimHei', 'sans-serif']`
    2.  or set it in your .matplotlibrc file:
        `font.sans-serif: SimHei, Arial, sans-serif`

# 标注

## 基本标注

### Basic annotation

1.  用户使用text()，可以将文本放在坐标轴中的任意位置。
2.  文本常用于注释图形的一些特性，而annotate()方法提供了辅助功能，使注释更容易
3.  在注释中，有两点需要考虑:由参数xy表示的被注释的位置和由xytext表示的文本的位置。
4.  这两个参数都是(x,y)元组。

### Basic annotation

![](images/1581585591.png)

### coordinate systems

1.  有各种各样的坐标系可供选择。
2.  可以使用以下xycoords和textcoords的字符串来指定xy和xytext的位置。
3.  (默认是 \'data\')

  argument              coordinate system
  --------------------- ----------------------------------------------------
  \'figure points\'     point  从图的左下角开始
  \'figure pixels\'     pixels 从图的左下角开始
  \'figure fraction\'   0,0 是图形的左下角 1,1 是右上角
  \'axes points\'       points 从坐标轴的左下角开始
  \'axes pixels\'       pixels 从坐标轴的左下角开始
  \'axes fraction\'     0,0 是坐标轴的左下角 1,1是右上角
  \'data\'              使用默认坐标设置

### 例子

``` {python}
import matplotlib.pyplot as plt
ax = plt.subplot(111)

t = np.arange(0.0, 5.0, 0.01)
s = np.cos(2*np.pi*t)
line, = plt.plot(t, s, lw=2)

ax.annotate('local max', xy=(3, 1),  xycoords='data',
            xytext=(0.8, 0.95), textcoords='axes fraction',
            arrowprops=dict(facecolor='black', shrink=0.05),
            horizontalalignment='right', verticalalignment='top',
            )

plt.ylim(-2, 2)
plt.show()
```

### argument `arrowprops`

1.  您可以通过在可选关键字参数`arrowprops`中提供箭头属性字典来启用箭头从文本到注释点的绘制.

  ---------------- ---------------------------------------------------------------------------
  arrowprops key   description
  width            箭头的宽度
  frac             箭头长度占头部的部分
  headwidth        箭头头部的宽度，以点为单位
  shrink           move the tip and base some percent away from the annotated point and text
  \*\*kwargs       any key for matplotlib.patches.Polygon, e.g., facecolor
  ---------------- ---------------------------------------------------------------------------

## 高级标注

### Annotating with Text with Box

1.  pyplot模块(或Axes类的text方法)中的text()函数,给定bbox关键字参数时在文本周围绘制一个框。
2.  与文本关联的patch对象可以通过以下方式访问:
    `bb = t.get_bbox_patch()`
3.  返回值是FancyBboxPatch的一个实例，可以像往常一样访问和修改patch属性，如facecolor、edgewidth等
4.  要更改方框的形状，通过设置~boxstyle~方法。
5.  `pad` ：内边距

``` {python}
bbox_props = dict(boxstyle="rarrow,pad=0.3", fc="cyan", ec="b", lw=2)
t = ax.text(0.5, 0.5, "Direction", ha="center", va="center", rotation=45,
            size=15,
            bbox=bbox_props)
bb = t.get_bbox_patch()
bb.set_boxstyle("rarrow", pad=0.6)
```

### box styles

  Class        Name         Attrs
  ------------ ------------ -----------------------------
  Circle       circle       pad=0.3
  DArrow       darrow       pad=0.3
  LArrow       larrow       pad=0.3
  RArrow       rarrow       pad=0.3
  Round        round        pad=0.3,rounding~size~=None
  Round4       round4       pad=0.3,rounding~size~=None
  Roundtooth   roundtooth   pad=0.3,tooth~size~=None
  Sawtooth     sawtooth     pad=0.3,tooth~size~=None
  Square       square       pad=0.3

### Fancybox list

``` {python}
import matplotlib.pyplot as plt
import matplotlib.transforms as mtransforms
import matplotlib.patches as mpatch
from matplotlib.patches import FancyBboxPatch

styles = mpatch.BoxStyle.get_styles()
spacing = 1.2
figheight = (spacing * len(styles) + .5)
fig = plt.figure(figsize=(4 / 1.5, figheight / 1.5))
fontsize = 0.3 * 72

for i, stylename in enumerate(sorted(styles)):
    fig.text(0.5, (spacing * (len(styles) - i) - 0.5) / figheight, stylename,
              ha="center",
              size=fontsize,
              transform=fig.transFigure,
              bbox=dict(boxstyle=stylename, fc="w", ec="k"))

plt.show()
```

### Annotating with Arrow

1.  绘制箭头需要几个步骤。
    -   创建两点之间的连接路径。这是由connectionstyle键值控制的。
    -   如果patch对象是给定的(patchA & patchB)，路径会被裁剪以避免patch。
    -   路径可以进一步缩小到给定的像素量 (shrinkA &
        shrinkB)
    -   路径转换为箭头patch对象，由箭头样式键值控制。


### 示意图


![](images/annotate_explain.png)

### `connectionstyle` key

1.  两点之间连接路径的创建由connectionstyle键控制。下面的示例(有限地)演示了每种连接样式的行为。

![](images/connectionstyle_demo.png)

### `arrowstyle`

1.  根据给定的`arrowstyle`，连接路径(经过剪切和收缩)转变为一个箭头

![](images/fancyarrow_demo.png)

### Using ConnectionPatch

1.  ConnectionPatch就像一个没有文本的注释。虽然在大多数情况下建议使用注释函数，但当您希望连接不同轴上的点时，`ConnectionPatch`非常有用。

1.  <https://matplotlib.org/gallery/userdemo/connect_simple01.html>

![](images/connect_simple.png)

### Zoom effect between Axes

1.  `mpl_toolkits.axes_grid1.inset_locator` 定义了一些有效链接两个轴的patch对象
2.  理解这些代码需要了解 mpl\'s transform 是如何工作的。

3.  <https://matplotlib.org/gallery/subplots_axes_and_figures/axes_zoom_effect.html>

![](images/axes_zoom_effect.png)

# mplot3d工具箱

### How is mplot3d different from MayaVi?（mplot3d和MayaVi有何不同）

1.  MayaVi2 is a very powerful and featureful 3D graphing library. For
    advanced 3D scenes and excellent rendering capabilities, it is
    highly recommended to use MayaVi2.（MayaVi2是一个非常有用功能丰富的3D会图
    库。有先进的3D图像和优秀的渲染能力，强力推荐使用MayaVi2）
2.  mplot3d was intended to allow users to create simple 3D graphs with
    the same \"look-and-feel\" as matplotlib\'s 2D plots. Furthermore,
    users can use the same toolkit that they are already familiar with
    to generate both their 2D and 3D plots.（mplot3d旨在允许用户使用与
    matplotlib's 2D plots有相同外观和感觉的简单3D图形，用户可以使用他们已经熟悉
    的生成2D和3D图的工具包toolkit）

### `Axes3D` object

1.  An Axes3D object is created just like any other axes using the
    `projection='3d'` keyword.（创建一个Axes3D对象和其他轴一样，使用
    `projection='3d'`这样的关键字）
2.  Create a new matplotlib.figure.Figure and add a new axes to it of
    type Axes3D:（创建一个新的画布并添加新的坐标轴）

``` {python}
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

```

### 一个例子

``` {python}
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import matplotlib.pyplot as plt

plt.rcParams['legend.fontsize'] = 10
fig = plt.figure()
ax = fig.gca(projection='3d')

# Prepare arrays x, y, z
theta = np.linspace(-4 * np.pi, 4 * np.pi, 100)
z = np.linspace(-2, 2, 100)
r = z**2 + 1
x = r * np.sin(theta)
y = r * np.cos(theta)

ax.plot(x, y, z, label='parametric curve')
ax.legend()

plt.show()
```

### 支持的 3D 图形类型

1.  <https://matplotlib.org/tutorials/toolkits/mplot3d.html#sphx-glr-tutorials-toolkits-mplot3d-py>
2.  Line plots： `Axes3D.plot(self, xs, ys, *args, zdir='z', **kwargs)`
3.  Scatter plots：
    `Axes3D.scatter(self, xs, ys, zs=0, zdir='z', s=20, c=None, depthshade=True, *args, **kwargs)`
4.  Wireframe plots：
    `Axes3D.plot_wireframe(self, X, Y, Z, *args, **kwargs)`
5.  Surface plots：
    `Axes3D.plot_surface(self, X, Y, Z, *args, norm=None, vmin=None, vmax=None, lightsource=None, **kwargs)`
6.  Tri-Surface plots：
    `Axes3D.plot_trisurf(self, *args, color=None, norm=None, vmin=None, vmax=None, lightsource=None, **kwargs)`
7.  Contour plots：
    `Axes3D.contour(self, X, Y, Z, *args, extend3d=False, stride=5, zdir='z', offset=None, **kwargs)`

### 支持的 3D 图形类型

1.  Filled contour plots：
    `Axes3D.contourf(self, X, Y, Z, *args, zdir='z', offset=None, **kwargs)`
2.  Polygon plots： `Axes3D.add_collection3d(self, col, zs=0, zdir='z')`
3.  Bar plots：
    `Axes3D.bar(self, left, height, zs=0, zdir='z', *args, **kwargs)`
4.  Quiver：
    `Axes3D.quiver(X, Y, Z, U, V, W, /, length=1, arrow_length_ratio=.3, pivot='tail', normalize=False, **kwargs)`
5.  2D plots in 3D
6.  Text： `Axes3D.text(self, x, y, z, s, zdir=None, **kwargs)`
7.  Subplotting：Having multiple 3D plots in a single figure is the same
    as it is for 2D plots. Also, you can have both 2D and 3D plots in
    the same figure.

### 其他常见作图包

1.  Pandas is handy for simple plots but you need to be willing to learn
    matplotlib to customize.（Pandas对于简单的情况比较方便，但是你需要愿意去学习matplotlib）
2.  Seaborn can support some more complex visualization approaches but
    still requires matplotlib knowledge to tweak. The color schemes are
    a nice bonus.（Seaborn可以支持更复杂的可视化方法，但是仍然需要matplotlib的知
    识去支撑，它的颜色主题部分很好用）
3.  ggplot ggplot is a plotting system for Python based on R\'s ggplot2
    and the Grammar of Graphics. It is built for making profressional
    looking, plots quickly with minimal code.（ggplot是一个基于R中ggplot2的Python
    绘图系统及图形语法，它是为了让研究人员看起来用最少的代码快速绘图）
4.  Bokeh is an interactive visualization library for modern web
    browsers. It provides elegant, concise construction of versatile
    graphics, and affords high-performance interactivity over large or
    streaming datasets.（ Bokeh是现代web浏览器的交互式可视化库，它提供了优雅、简
    洁的多功能图形构建，以及提供大型或主流的高性能的交互性数据库）
5.  Mayavi: 3D scientific data visualization and plotting in Python.（Mayavi使用
Python进行科学数据可视化和绘制）
6.  Turtle graphics is a popular way for introducing programming to
    kids.（Turtle graphics是向孩子们介绍编程的一种流行方式）


# 参考文献
[//]: # (\bibliography{Bibfile})
